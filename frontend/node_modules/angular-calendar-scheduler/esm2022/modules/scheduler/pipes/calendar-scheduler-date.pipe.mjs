import { Pipe, LOCALE_ID, Inject } from '@angular/core';
import { CalendarDateFormatter } from 'angular-calendar';
import * as i0 from "@angular/core";
import * as i1 from "angular-calendar";
export class CalendarSchedulerDatePipe {
    dateAdapter;
    dateFormatter;
    locale;
    constructor(dateAdapter, dateFormatter, locale) {
        this.dateAdapter = dateAdapter;
        this.dateFormatter = dateFormatter;
        this.locale = locale;
    }
    transform(date, method, locale = this.locale, weekStartsOn = 0, excludeDays = [], daysInWeek, startsWithToday) {
        if (typeof this.dateFormatter[method] === 'undefined') {
            const allowedMethods = Object.getOwnPropertyNames(Object.getPrototypeOf(CalendarDateFormatter.prototype)).filter(iMethod => iMethod !== 'constructor');
            throw new Error(`${method} is not a valid date formatter. Can only be one of ${allowedMethods.join(', ')}`);
        }
        return this.dateFormatter[method]({
            dateAdapter: this.dateAdapter,
            date,
            locale,
            weekStartsOn,
            excludeDays,
            daysInWeek,
            startsWithToday
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.7", ngImport: i0, type: CalendarSchedulerDatePipe, deps: [{ token: i1.DateAdapter }, { token: i1.CalendarDateFormatter }, { token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Pipe });
    static ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "16.2.7", ngImport: i0, type: CalendarSchedulerDatePipe, name: "calendarSchedulerDate" });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.7", ngImport: i0, type: CalendarSchedulerDatePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'calendarSchedulerDate'
                }]
        }], ctorParameters: function () { return [{ type: i1.DateAdapter }, { type: i1.CalendarDateFormatter }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXItc2NoZWR1bGVyLWRhdGUucGlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYi9tb2R1bGVzL3NjaGVkdWxlci9waXBlcy9jYWxlbmRhci1zY2hlZHVsZXItZGF0ZS5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQWlCLFNBQVMsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdkUsT0FBTyxFQUFFLHFCQUFxQixFQUFlLE1BQU0sa0JBQWtCLENBQUM7OztBQUt0RSxNQUFNLE9BQU8seUJBQXlCO0lBRTFCO0lBQ0E7SUFDbUI7SUFIN0IsWUFDVSxXQUF3QixFQUN4QixhQUFvQyxFQUNqQixNQUFjO1FBRmpDLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQ3hCLGtCQUFhLEdBQWIsYUFBYSxDQUF1QjtRQUNqQixXQUFNLEdBQU4sTUFBTSxDQUFRO0lBQ3hDLENBQUM7SUFFSixTQUFTLENBQ1AsSUFBVSxFQUNWLE1BQWMsRUFDZCxTQUFpQixJQUFJLENBQUMsTUFBTSxFQUM1QixlQUF1QixDQUFDLEVBQ3hCLGNBQXdCLEVBQUUsRUFDMUIsVUFBbUIsRUFDbkIsZUFBeUI7UUFFekIsSUFBSSxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEtBQUssV0FBVyxFQUFFO1lBQ3JELE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBQyxtQkFBbUIsQ0FDL0MsTUFBTSxDQUFDLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLENBQUMsQ0FDdkQsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEtBQUssYUFBYSxDQUFDLENBQUM7WUFDL0MsTUFBTSxJQUFJLEtBQUssQ0FDYixHQUFHLE1BQU0sc0RBQXNELGNBQWMsQ0FBQyxJQUFJLENBQ2hGLElBQUksQ0FDTCxFQUFFLENBQ0osQ0FBQztTQUNIO1FBQ0QsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2hDLFdBQVcsRUFBRSxJQUFJLENBQUMsV0FBVztZQUM3QixJQUFJO1lBQ0osTUFBTTtZQUNOLFlBQVk7WUFDWixXQUFXO1lBQ1gsVUFBVTtZQUNWLGVBQWU7U0FDaEIsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzt1R0FuQ1UseUJBQXlCLGtGQUkxQixTQUFTO3FHQUpSLHlCQUF5Qjs7MkZBQXpCLHlCQUF5QjtrQkFIckMsSUFBSTttQkFBQztvQkFDSixJQUFJLEVBQUUsdUJBQXVCO2lCQUM5Qjs7MEJBS0ksTUFBTTsyQkFBQyxTQUFTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSwgTE9DQUxFX0lELCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ2FsZW5kYXJEYXRlRm9ybWF0dGVyLCBEYXRlQWRhcHRlciB9IGZyb20gJ2FuZ3VsYXItY2FsZW5kYXInO1xyXG5cclxuQFBpcGUoe1xyXG4gIG5hbWU6ICdjYWxlbmRhclNjaGVkdWxlckRhdGUnXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBDYWxlbmRhclNjaGVkdWxlckRhdGVQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIGRhdGVBZGFwdGVyOiBEYXRlQWRhcHRlcixcclxuICAgIHByaXZhdGUgZGF0ZUZvcm1hdHRlcjogQ2FsZW5kYXJEYXRlRm9ybWF0dGVyLFxyXG4gICAgQEluamVjdChMT0NBTEVfSUQpIHByaXZhdGUgbG9jYWxlOiBzdHJpbmdcclxuICApIHt9XHJcblxyXG4gIHRyYW5zZm9ybShcclxuICAgIGRhdGU6IERhdGUsXHJcbiAgICBtZXRob2Q6IHN0cmluZyxcclxuICAgIGxvY2FsZTogc3RyaW5nID0gdGhpcy5sb2NhbGUsXHJcbiAgICB3ZWVrU3RhcnRzT246IG51bWJlciA9IDAsXHJcbiAgICBleGNsdWRlRGF5czogbnVtYmVyW10gPSBbXSxcclxuICAgIGRheXNJbldlZWs/OiBudW1iZXIsXHJcbiAgICBzdGFydHNXaXRoVG9kYXk/OiBib29sZWFuXHJcbiAgKTogc3RyaW5nIHtcclxuICAgIGlmICh0eXBlb2YgdGhpcy5kYXRlRm9ybWF0dGVyW21ldGhvZF0gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIGNvbnN0IGFsbG93ZWRNZXRob2RzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoXHJcbiAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKENhbGVuZGFyRGF0ZUZvcm1hdHRlci5wcm90b3R5cGUpXHJcbiAgICAgICkuZmlsdGVyKGlNZXRob2QgPT4gaU1ldGhvZCAhPT0gJ2NvbnN0cnVjdG9yJyk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgJHttZXRob2R9IGlzIG5vdCBhIHZhbGlkIGRhdGUgZm9ybWF0dGVyLiBDYW4gb25seSBiZSBvbmUgb2YgJHthbGxvd2VkTWV0aG9kcy5qb2luKFxyXG4gICAgICAgICAgJywgJ1xyXG4gICAgICAgICl9YFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuZGF0ZUZvcm1hdHRlclttZXRob2RdKHtcclxuICAgICAgZGF0ZUFkYXB0ZXI6IHRoaXMuZGF0ZUFkYXB0ZXIsXHJcbiAgICAgIGRhdGUsXHJcbiAgICAgIGxvY2FsZSxcclxuICAgICAgd2Vla1N0YXJ0c09uLFxyXG4gICAgICBleGNsdWRlRGF5cyxcclxuICAgICAgZGF5c0luV2VlayxcclxuICAgICAgc3RhcnRzV2l0aFRvZGF5XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuIl19